import collections
 
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        # Find connected components and check how many infected nodes are in this component
        ans = min(initial)
        global_max = 0 
        
        for infected in sorted(initial):
            infected_count, infected_node, size = self.dfs(graph, set(initial), infected)
            if infected_count == 1 and size > global_max:
                global_max = size
                ans = infected_node
                    
        return ans 
        
    def dfs(self, graph, initial, node):
        queue = collections.deque([node])
        infected_count = 0
        infected_node = None
        size = 0 
        local_seen = set([node])
        while queue:
            curr = queue.popleft() 
            size += 1
            if curr in initial:
                infected_count += 1
                infected_node = curr
            
            for neighbor, is_edge in enumerate(graph[curr]):
                if is_edge and neighbor not in local_seen:
                    local_seen.add(neighbor)
                    queue.append(neighbor)
                    
        return infected_count, infected_node, size

s= Solution()
graph = [[1,0,0,1,0],[0,1,0,0,1],[0,0,1,0,0],[1,0,0,1,0],[0,1,0,0,1]]
initial = [0,4]
print(s.minMalwareSpread(graph, initial))

graph = [[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]]
initial = [3,1]
print(s.minMalwareSpread(graph, initial))

